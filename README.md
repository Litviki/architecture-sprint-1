# Задание №1:

#### Дано:
Дан веб-сайт, представляющий собой клиент-серверную архитектуру с реализацией клиента с использованием фреймворка React на языке JavaScript,
а также бэкенда на языке TypeScript с использованием фреймворка Express.js и хранилищем MongoDB.

Проанализировав функциональность сайта, можно выделить следующие возможности для пользователя:
* Как пользователь, я могу зарегистрировать учетную запись.
* Как пользователь, я могу войти в учетную запись.
* Как пользователь, я могу выйти из учетной записи.
* Как пользователь, я могу редактировать данные учетной записи.
* Как пользователь, я могу редактировать аватар учетной записи.
* Как пользователь, я могу сохранять фото-контент на веб-сайте.
* Как пользователь, я могу удалять фото-контент из своего профиля на веб-сайте.
* Как пользователь, я могу поставить лайк под фото-контентом.
* Как пользователь, я могу убрать лайк с фото-контента.

#### Данный функционал системы можно поделить на следующие домены:
| Домены                                          | Функционал                                                                                                                                         |
|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| **идентификация и аутентификация пользователя** | как пользователь, я могу зарегистрироваться<br>как пользователь, я могу войти в учётную запись<br>как пользователь, я могу выйти из учётной записи |
| **профиль пользователя**                        | как пользователь, я могу редактировать данные учётной записи<br>как пользователь, я могу редактировать аватар учётной записи               |
| **каталог фото-контента пользователя**          | как пользователь, я могу сохранять фото-контент на веб-сайте<br>как пользователь, я могу удалять фото-контент из своего профиля<br>как пользователь, я могу поставить лайк под фото-контентом<br>как пользователь, я могу убрать лайк с фото-контента|

#### Метод реализации микрофронтендов:
Метод реализации микрофронтендов был выбран <i>Run Time</i> в гибридном подходе для использования преимуществ как серверной компоновки, так и клиентской. 
В нашей реализации клиент будет инициировать взаимодействие с сервером, отправляя HTTP-запросы. Сервер будет возвращать клиенту JSON с данными,
которые клиент будет парсить и передавать в React-компоненты для рендеринга. После этого данные могут изменяться разными микрофронтендами при взаимодействии с пользователем, 
используя глобальное состояние приложения.

Выбор метода <i>Run Time</i> был сделан по следующим причинам:
1. <b>Гибкость и динамичность:</b> Этот метод позволяет загружать и изменять компоненты приложения на лету, 
что повышает гибкость и позволяет быстрее реагировать на изменения требований.
2. <b>Меньшая зависимость от сборки:</b> В отличие от <i>Build Time</i>,
<i>Run Time</i> метод не требует повторной сборки всего приложения при изменении одного из микрофронтендов.
3. <b>Упрощенная интеграция и развертывание:</b> В случае развертывания новых функций или исправлений можно обновлять только соответствующие микрофронтенды 
без необходимости полного разворачивания всего приложения.
4. <b>Поддержка модульности и изоляции:</b> Микрофронтенды могут быть разработаны и развернуты независимо друг от друга, 
что улучшает модульность и изоляцию компонентов.

Таким образом, использование метода <i>Run Time</i> предоставляет значительные преимущества в гибкости, 
масштабируемости и простоте управления приложением.

#### Выбор фреймворка микрофронтендов:
Для создания микрофронтендов я использовал фреймворк <i>Webpack Module Federation</i>. 

Этот выбор обусловлен следующими причинами:

* <b>Общий код:</b> В проекте есть общий код, который будет использоваться несколькими микрофронтендами. 
Webpack Module Federation позволяет эффективно шарить (разделять) общий код между микрофронтендами, 
избегая дублирования и улучшая производительность.

* <b>Единый фреймворк:</b> Поскольку все микрофронтенды используют один и тот же фронтенд-фреймворк (React), 
Webpack Module Federation позволяет легко интегрировать их между собой без необходимости использования разных фреймворков.

* <b>Гибкость и масштабируемость:</b> <i>Webpack Module Federation</i> поддерживает динамическую загрузку модулей, 
что упрощает разработку и развертывание микрофронтендов, позволяя обновлять или заменять части приложения без перезагрузки всей страницы.

Список микрофронтендов состоит из выделенных в проекте доменов,
а также дополнительных микрофронтов для реализации архитектуры микрофронтов. 

Вот список микрофронтов и их порты:
* <b>main-application (3000)</b> - главное приложение, которое импортирует и рендерит компоненты из микрофронтендов.
* <b>authentication-microfrontend (3001)</b> - отвечает за аутентификацию пользователей. Включает в себя все компоненты, 
необходимые для регистрации, входа в систему и проверки токенов пользователя.
* <b>profile-microfrontend (3002)</b> - отвечает за управление профилем пользователя. 
Здесь находятся компоненты для просмотра и редактирования информации профиля пользователя.
* <b>shared-components (3003)</b> - каталог содержит общие компоненты, которые используются в различных микрофронтендах. 
Сюда входят такие компоненты, как заголовки, подвали, формы, попапы, а также утилиты и контексты.
* <b>card-management-microfrontend (3004)</b> - управляет карточками (например, добавление, удаление, редактирование карточек). 
Он содержит компоненты и логику, связанные с операциями над карточками.
* <b>store (3005)</b> - отдельным модулем я выделил глобальное состояние приложения, 
импортировав который каждый компонент системы может получить доступ к глобальному состоянию приложения.

Для внедрения инструмента нужно убедиться, что мы используем не ниже Webpack 5. 
Затем необходимо создать конфигурационный файл `webpack.config.js` для каждого из микрофронтендов, включая главное приложение. 
В этих конфигурационных файлах следует указать импортируемые и экспортируемые модули. 
После этого компоненты могут использоваться в коде практически как при обычном импорте.

Я использовал команды:
* Создание нового микрофронтенда:
```
npx create-mf-app
```

* Установка зависимостей:
```
npm install
```

* Запуск микрофронтенда:
```
npm start
```

#### Межмодульное взаимодействие:
Межмодульное взаимодействие я реализовал через библиотеку глобального состояния MobX. Клиент получает данные с бэка и сохраняет их в состояние, 
после чего каждый из микрофронтендов может изменить состояние, что отобразится и на других микрофронтендах сайта.

Почему глобальное состояние приложения:
* <b>Согласованность данных:</b> Глобальное состояние позволяет всем микрофронтендам иметь доступ к одному и тому же набору данных, 
что обеспечивает согласованность и синхронизацию данных между компонентами.
* <b>Упрощение взаимодействия:</b> Использование глобального состояния упрощает взаимодействие между микрофронтендами, 
так как они могут напрямую обращаться к общему состоянию, а не через сложные механизмы передачи данных.
* <b>Повышение производительности:</b> Взаимодействие через глобальное состояние снижает количество запросов к серверу и уменьшает задержки, 
связанные с передачей данных.

Почему не Pub-Sub или API/BFF:
* <b>Pub-Sub:</b> Использование Pub-Sub (Publish-Subscribe) может усложнить архитектуру приложения, 
так как потребуется настроить каналы для передачи данных и управлять подписками/оповещениями. 
Это добавляет дополнительный уровень сложности и может привести к ошибкам в случае неправильной настройки.
* <b>API/BFF:</b> Взаимодействие через API или Backend-for-Frontend (BFF) может привести к избыточным запросам к серверу и увеличению времени отклика приложения. 
Это также усложняет разработку и тестирование, так как нужно поддерживать дополнительный слой API.

Почему MobX:
* <b>Простота использования:</b> MobX предоставляет простой и интуитивно понятный API для работы с состоянием, что ускоряет разработку и снижает вероятность ошибок.
* <b>Реактивность:</b> MobX автоматически отслеживает зависимости и обновляет компоненты при изменении состояния, что обеспечивает высокую производительность и отзывчивость интерфейса.
* <b>Личный опыт:</b> Я уже имел опыт работы с MobX, что позволяет мне более эффективно использовать его возможности и быстро интегрировать в проект.

#### Диаграмма архитектуры микрофронтендов:
![microfrontends_diagram.drawio.svg](microfrontends_diagram.drawio.svg)


# Задание №2:
![solution1.2.drawio.svg](solution1.2.drawio.svg)
